## 基于A*算法的水果消除游戏实验报告

#### 1. 实验概述

本实验实现了一个基于A*搜索算法的水果消除游戏，目标是通过滑动棋盘上的水果，使得同种水果位于同行/同列且中间没有其他水果阻挡从而被消除，最终清空整个棋盘。

#### 2. 搜索算法设计思路

##### 2.1 问题建模

**状态表示**：使用二维NumPy数组表示棋盘状态，其中0 表示空格子，1, 2, 3... 表示不同种类的水果

**动作定义**：水果可以向上、下、左、右四个方向滑动到相邻的空格子中，每移动一个格子有相应代价，默认代价为1

**目标状态**：所有格子都为0的状态（棋盘完全清空）

##### 2.2 A*算法核心组件

##### 2.2.1 状态节点设计

```python
class Node():
    def __init__(self, state, parent, move, path_cost, custom_costs=None):
        self.state = state          # 当前棋盘状态
        self.parent = parent        # 父节点
        self.move = move           # 从父节点到当前节点的移动
        self.path_cost = path_cost  # 从起始节点到当前节点的实际代价
        self.custom_costs = custom_costs  # 自定义滑动代价
```

##### 2.2.2 评价函数设计

评价函数 $f(n)=g(n)+h(n)$，$g(n)$ 表示已经走过的路径代价，$h(n)$ 为启发函数。

启发函数的设计思路：将问题简化为**只要将同种水果移动到同行/同列即可消除**时的路径代价，即不考虑中间是否有其他种水果或两种水果重叠的情况。

```python
def heuristic(self, costs=None):
    #评价函数，估计到达目标状态的代价+路径代价
    board = self.state
    if np.all(board == 0):
        self._heuristic_value = self.path_cost
        return self._heuristic_value

    # 使用节点的自定义代价，如果没有则使用传入的costs，最后默认为1    
    use_costs = self.custom_costs if self.custom_costs else costs

    fruit_types = int(np.max(board))
    h = 0
    for i in range(1, fruit_types+1):
        positions = np.argwhere(board == i)
        if len(positions) == 2:
            (x1, y1), (x2, y2) = positions
            h += min(abs(x1 - x2), abs(y1 - y2)) * (use_costs[i-1] if use_costs else 1)

    self._heuristic_value = h + self.path_cost
    return self._heuristic_value
```

##### 2.2.3 A*算法

**a. 预处理**：消除初始状态可以消除的水果，创建根节点

```python
eliminate(board)
start_node = Node(np.array(board), None, None, 0, custom_costs=costs)
```

**b. 初始化数据结构**：

- 用优先队列存储待访问节点（按照评价函数值排序）；
- 用哈希集合closed_set存储已访问状态，open_set存储开放列表中的状态。

```python
open_heap = []
heapq.heappush(open_heap, start_node)

closed_set = set()
open_set = set()  

start_state_hash = hash(tuple(start_node.state.flatten()))
open_set.add(start_state_hash)
```

**c. 搜索循环**：

- 取出优先队列中f值最小的节点，同时将其从开集合中移除，加入闭集合；
- 检查是否为目标状态，是则终止循环返回当前节点；
- 扩展当前节点的子节点，将未访问过的状态同时加入优先队列和开集合。

```python
while open_heap:
    current_node = heapq.heappop(open_heap)
    current_state_hash = hash(tuple(current_node.state.flatten()))
    open_set.discard(current_state_hash)

    if current_state_hash in closed_set:
        continue
    closed_set.add(current_state_hash)

    if np.all(current_node.state == 0):
        return current_node

    for child in current_node.expand():
        child_state_hash = hash(tuple(child.state.flatten()))

        if child_state_hash not in closed_set and child_state_hash not in open_set:
            heapq.heappush(open_heap, child)
            open_set.add(child_state_hash)
```

#### 3. 搜索算法结果演示

##### 3.1 测试案例设置

**测试配置**：
- 棋盘大小：4×4
- 水果种类：3种
- 自定义代价：水果1(1), 水果2(3), 水果3(5)

**初始状态示例**：

![截屏2025-10-19 11.03.53](/Users/rst/Library/Application Support/typora-user-images/截屏2025-10-19 11.03.53.png)

```python
最终方阵：
[0, 1, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 5, 0, 0, 0]
[0, 0, 0, 0, 2, 0, 0, 0]
[0, 5, 0, 0, 0, 4, 0, 0]
[0, 0, 0, 0, 3, 1, 3, 0]
[0, 0, 0, 0, 0, 4, 0, 2]
[0, 0, 0, 0, 0, 0, 0, 0]
```

##### 3.2 求解过程可视化

**控制台输出示例**：

```python
Moves to solve the board:
第1步: ((0, 1), (0, 2), 1) (代价: 1)
第2步: ((0, 2), (0, 3), 1) (代价: 1)
第3步: ((0, 3), (0, 4), 1) (代价: 1)
第4步: ((5, 4), (5, 3), 3) (代价: 3)
第5步: ((5, 5), (5, 4), 1) (代价: 1)
第6步: ((3, 4), (3, 5), 2) (代价: 2)
第7步: ((2, 4), (3, 4), 5) (代价: 5)
第8步: ((3, 4), (4, 4), 5) (代价: 5)
第9步: ((3, 5), (3, 6), 2) (代价: 2)
第10步: ((3, 6), (3, 7), 2) (代价: 2)
总代价: 23
```

##### 3.3 图形界面演示功能

![截屏2025-10-19 11.07.11](/Users/rst/Desktop/截屏2025-10-19 11.07.11.png)

**a. 路径高亮显示**

- 橙色边框：移动起点
- 绿色边框：移动终点
- 实时更新棋盘状态

**b. 步进控制**

- "下一步"：单步执行移动
- "上一步"：回退到前一状态
- "自动演示"：连续播放解决方案
- "重置"：返回初始状态

**c. 代价信息显示**

- 实时显示当前步骤的移动代价
- 完成时显示总代价

#### 4. 讨论

##### 4.1 调试过程中遇到的问题

- **问题描述**：直接使用曼哈顿距离作为启发函数可能会高估代价，导致找不到最优解。

  **解决方案**：使用曼哈顿距离的最小值作为保守估计。

- **问题描述**：早期版本使用列表存储待访问状态和已访问状态，搜索效率较低。

  **解决方案**：使用优先队列，确保每次取出f值最小的节点；使用集合(set)替代列表存储状态哈希值。

##### 4.2 算法改进空间

##### 4.2.1 启发函数进一步优化

当前的启发函数未考虑水果间的相互阻挡，可以设计考虑路径阻挡的更复杂的启发函数。

##### 4.2.2 搜索策略改进

可能的改进：
1. 双向搜索：从初始状态和目标状态同时搜索

2. 迭代深化A*：在内存受限环境下的选择

   

#### **项目文件结构**：

```
人工智能原理/
├── GUIstudy.py          # 主程序文件
├── 砖.py                # 早期版本（参考）
├── 实验报告.md          # 本报告
└── fruit*.png           # 水果图像资源（可选）
```

**运行环境**：
- Python 3.14.0
- tkinter（GUI库）
- numpy（数值计算）
- heapq（优先队列）